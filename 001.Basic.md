## .Net Core Basics
* **.net core**  - It is open source,cross Platform, light and dependency injection is an added advantage.

* **Dependency Injection** - It is a design pattern that allows to pass dependency to objects instead of creating it inside, This way the classes will be loosly copuled and easy to change, test and reuse the code.
   By exposing dependencies in the constructor, you expose public information about the needs of your code, further explaining what it does and what it's needs are..

## `ConfigureServices` vs `Configure` in ASP.NET Core

Both live in `Startup.cs` (or in `Program.cs` in minimal hosting model after .NET 6). They serve **different purposes** in app startup:

---

## 1. **ConfigureServices(IServiceCollection services)**

* Purpose: **Register dependencies & services** with the built-in Dependency Injection (DI) container.
* Called **at application startup**, before the pipeline is built.
* Adds things that your app needs later (DB, Identity, Logging, Authentication, etc.).

### Example:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    // Register MVC / API controllers
    services.AddControllers();

    // Register Entity Framework DbContext
    services.AddDbContext<AppDbContext>(options =>
        options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));

    // Add Authentication (JWT for example)
    services.AddAuthentication("Bearer")
        .AddJwtBearer(...);

    // Register custom services
    services.AddScoped<IEmailService, EmailService>();
}
```

‚úÖ Think: **‚ÄúWhat my app needs to run?‚Äù ‚Üí Register here.**

---

## 2. **Configure(IApplicationBuilder app, IWebHostEnvironment env)**

* Purpose: **Build the HTTP request pipeline (Middleware pipeline).**
* Defines how an HTTP request is handled and what components are executed in sequence.
* Runs **after services are registered**.

### Example:

```csharp
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    else
    {
        app.UseExceptionHandler("/Home/Error");
        app.UseHsts();
    }

    // Middleware pipeline
    app.UseHttpsRedirection();
    app.UseStaticFiles();

    app.UseRouting();

    app.UseAuthentication();  // Must come before Authorization
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();  // Map API controllers
        endpoints.MapRazorPages();   // If Razor Pages are used
    });
}
```

‚úÖ Think: **‚ÄúHow my app should handle requests?‚Äù ‚Üí Define here.**

---

# üîë Quick Summary

| Method                | Purpose                            | Examples                                                               |
| --------------------- | ---------------------------------- | ---------------------------------------------------------------------- |
| **ConfigureServices** | Register services (DI container)   | `AddDbContext`, `AddControllers`, `AddAuthentication`, custom services |
| **Configure**         | Define middleware request pipeline | `UseRouting`, `UseAuthentication`, `UseAuthorization`, `UseEndpoints`  |

---

üëâ A simple way to remember:

* **ConfigureServices ‚Üí What you need**
* **Configure ‚Üí How you handle requests**

---

Do you want me to also show how this changed in **.NET 6+ minimal hosting model** (where `ConfigureServices` & `Configure` are merged into `Program.cs`)?

##Program.cs file

<pre class="notranslate">
<code>
public class Program
    {
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                .UseSerilog((hostingContext, loggerConfiguration) => loggerConfiguration
            .ReadFrom.Configuration(hostingContext.Configuration))
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseStartup<Startup>();
                    
                });
    }
</code></pre>

##Starup.cs
<pre>
	<code>
	public void ConfigureServices(IServiceCollection services)
        {
            services.AddMemoryCache(); 
            services.AddTransient<IClientService, ClientService>(); 
            services.AddControllers();            
            services.AddSwaggerGen(c =>
            {
                c.SwaggerDoc("v1", new OpenApiInfo { Title = "Test.Title", Version = "v1" });
                c.ResolveConflictingActions(a => a.First());
            });
        }
		    
>>>>>> Configure Method.
		    
	public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment() || _ebsConfiguration.EnableSwagger )
            {
                app.UseDeveloperExceptionPage();
                app.UseSwagger();
                app.UseSwaggerUI(c =>
                {
                    c.ConfigObject.AdditionalItems["syntaxHighlight"] = new Dictionary<string, object>
                    {
                        ["activated"] = false
                    };
                    c.SwaggerEndpoint("/swagger/v1/swagger.json", "EBS.Core v1");
                });
            }

            app.UseHttpsRedirection();
            app.UseRouting();
            app.UseAuthorization();
            app.UseEndpoints(endpoints =>
            {
                endpoints.MapControllers();
            });
        }
	</code>
</pre>
Below is the **exact .NET 8 style** `Program.cs` and optional `Startup.cs` pattern ‚Äî with all **common configurations you MUST know for interviews.**

---

# ‚úÖ **.NET 8 Hosting Model (No Startup.cs by default)**

.NET 8 uses **minimal hosting model** ‚Üí everything is usually in `Program.cs`.

---

# üëâ **Program.cs (Standard .NET 8 Template)**

```csharp
var builder = WebApplication.CreateBuilder(args);

// -------------------
// 1. Add Services
// -------------------

builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Dependency Injection
builder.Services.AddScoped<IMyService, MyService>();

// Database (EF Core example)
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

// CORS
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAll", policy =>
    {
        policy.AllowAnyHeader()
              .AllowAnyMethod()
              .AllowAnyOrigin();
    });
});

// Authentication (JWT)
builder.Services.AddAuthentication("Bearer")
    .AddJwtBearer("Bearer", options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuerSigningKey = true,
            ValidateIssuer = false,
            ValidateAudience = false,
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"]))
        };
    });

// Logging
builder.Logging.ClearProviders();
builder.Logging.AddConsole();

// Configuration Binding (IOptions)
builder.Services.Configure<AppSettings>(
    builder.Configuration.GetSection("AppSettings"));


var app = builder.Build();

// -------------------
// 2. Middleware Pipeline
// -------------------

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

app.UseCors("AllowAll");

app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();

app.Run();
```

---

# ‚≠ê **Configurations Done in Program.cs**

### **Service Registration (builder.Services...)**

You configure:

* Controllers
* Swagger
* EF Core DbContext
* CORS policies
* Authentication (JWT)
* Authorization policies
* Dependency injection for services
* Logging providers
* HttpClient
* Configuration binding (IOptions)
* Health Checks
* Background services

---

### **Middleware Pipeline (app...)**

You configure:

* Exception handling
* Swagger UI
* HTTPS redirection
* CORS
* Authentication
* Authorization
* Routing
* Static files
* Custom middleware
* Endpoint mappings (MapControllers / MapGet etc.)

---

# üöÄ **If You Want Startup.cs Style in .NET 8**

Even though .NET 8 doesn‚Äôt use Startup.cs, you can still add it for clarity.

---

# üëâ **Startup.cs (Custom but Valid in .NET 8)**

### Program.cs:

```csharp
var builder = WebApplication.CreateBuilder(args);

var startup = new Startup(builder.Configuration);

startup.ConfigureServices(builder.Services);

var app = builder.Build();

startup.Configure(app, app.Environment);

app.Run();
```

---

### Startup.cs:

```csharp
public class Startup
{
    public IConfiguration Configuration { get; }

    public Startup(IConfiguration configuration)
    {
        Configuration = configuration;
    }

    // -------------------
    // ConfigureServices
    // -------------------
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddControllers();
        services.AddEndpointsApiExplorer();
        services.AddSwaggerGen();

        services.AddDbContext<AppDbContext>(options =>
            options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));

        services.AddScoped<IMyService, MyService>();

        services.AddCors(options =>
        {
            options.AddPolicy("AllowAll", p => p.AllowAnyHeader().AllowAnyMethod().AllowAnyOrigin());
        });

        services.Configure<AppSettings>(Configuration.GetSection("AppSettings"));
    }

    // -------------------
    // Configure
    // -------------------
    public void Configure(WebApplication app, IWebHostEnvironment env)
    {
        if (env.IsDevelopment())
        {
            app.UseSwagger();
            app.UseSwaggerUI();
        }

        app.UseHttpsRedirection();

        app.UseCors("AllowAll");

        app.UseAuthorization();

        app.MapControllers();
    }
}
```

---

# üî• **Where We Configure What? ‚Äî Interview Winning Table**

| Area                      | Where It Is Configured | Example                    |
| ------------------------- | ---------------------- | -------------------------- |
| **Services / DI**         | `builder.Services`     | AddDbContext, AddScoped    |
| **Controllers**           | Services               | AddControllers             |
| **Swagger**               | Services + Middleware  | AddSwaggerGen / UseSwagger |
| **Logging**               | builder.Logging        | AddConsole                 |
| **Database**              | Services               | AddDbContext               |
| **CORS Policies**         | Services               | AddCors                    |
| **CORS Usage**            | Middleware             | UseCors                    |
| **Authentication**        | Services               | AddJwtBearer               |
| **Authorization**         | Middleware             | UseAuthorization           |
| **Middleware Pipeline**   | app.UseX               | UseHttps, UseAuth          |
| **Routing**               | app.MapX               | MapControllers             |
| **Configuration Binding** | Services               | Configure<T>()             |

---

# üéØ **If interviewer asks:**

### **Where do you write what?**

Answer this:

> ‚ÄúAll service registrations like DB, DI, authentication, CORS, logging go inside
> `builder.Services`.
> And all middleware components like HTTPS redirection, authentication, authorization, CORS, exception handling and routing go inside the `app.Use...` pipeline after `app = builder.Build()`.‚Äù

**2. AddTransient Vs AddScoped Vs AddSingleton In ASP.NET Core**

 
<table>
<tr>
	<th>Service Type </th>
	<th>In scope of given Http request </th>
	<th>In different Http request</th>
</tr>
	<tbody>
	<tr>
		<td>Scope Service </td>
		<td>Same Instance </td>
		<td>New Instance </td>			
	</tr>
	<tr>
		<td>Transient Service </td>
		<td>New Instance </td>
		<td>New Instance </td>			
	</tr>	
	<tr>
		<td>Singleton Service </td>
		<td>Same Instance </td>
		<td>Same Instance </td>			
	</tr>		
	</tbody>
</table>

** AddScoped : In scoped, in the given http request same instnace of object will be provided thourout the request.
** AddTransient : In transient, with in the same request if that object is injected in more then one class different instance will be provided but in case of scoped same will be provided.

![NetCore](https://github.com/fullstackdeveloper007/InterviewQuestions/assets/96370256/8795f7b8-9331-4f5c-a418-a9ed70ed4d83)
* **AddTransient** - Transient lifetime services are created each time they are requested. This lifetime works best for lightweight, stateless services.

* **AddScoped** -
Scoped lifetime services are created once per request.

* **AddSingleton** -
Singleton lifetime services are created the first time they are requested (or when ConfigureServices is run if you specify an instance there) and then every subsequent request will use the same instance.

  **Example :**
  In startup.cs 
  <div> 
  <pre class="notranslate">
      <code> 
      public void ConfigureServices(IServiceCollection services)
      {
           services.AddScoped<ClassName>();
           services.AddTransient<IInterface, ClassName>();
          services.AddTransient<IInterface, ClassName>();
      } 
  </code></pre>
 </div>
 
**3. Understanding Middleware In ASP.NET Core**
<p>**Refrence Article :**  https://www.c-sharpcorner.com/article/overview-of-middleware-in-asp-net-core/</p>
<div>
Middle ware is injected in application pipeline to handle the request and responses.For instance, There can have one middleware component to authenticate users, another piece of middleware to handle errors, and another middleware to serve static files such as JavaScript, CSS, images, etc.
It .Net core we inject the middle ware inside **Configure method** of startup class.<br/>
 
<pre class="notranslate">
<code>
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)    
{    
    if (env.IsDevelopment())    
    {    
        //This middleware is used reports app runtime errors in development environment.  
        app.UseDeveloperExceptionPage();    
    }    
    else    
    {    
        **//This middleware is catches exceptions thrown in production environment. **  
        app.UseExceptionHandler("/Error");   
        // The default HSTS value is 30 days. You may want to change this for production scenarios, .    
        app.UseHsts(); //adds the Strict-Transport-Security header.    
    }    
    //This middleware is used to redirects HTTP requests to HTTPS.  
    app.UseHttpsRedirection();   
    
    //This middleware is used to returns static files and short-circuits further request processing.   
    app.UseStaticFiles();  
    
    //This middleware is used to route requests.   
    app.UseRouting();   
    
    //This middleware is used to authorizes a user to access secure resources.  
    app.UseAuthorization();    
    
    //This middleware is used to add Razor Pages endpoints to the request pipeline.    
    app.UseEndpoints(endpoints =>    
    {    
        endpoints.MapRazorPages();               
    });    
} 
</code></pre> 
</div>

**a) app.Run()** -
This middleware component may expose Run[Middleware] methods that are executed at the end of the pipeline. Generally, this acts as a terminal middleware and is added at the end of the request pipeline, as it cannot call the next middleware.

**b) app.Use()**
This is used to configure multiple middleware. Unlike app.Run(), We can include the next parameter into it, which calls the next request delegate in the pipeline. We can also short-circuit (terminate) the pipeline by not calling the next parameter. 
<pre>
<code>
 public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
      if (env.IsDevelopment() || _ebsConfiguration.EnableSwagger )
      {
         app.UseDeveloperExceptionPage();
          app.UseSwagger();
          app.UseSwaggerUI(c =>
          {
              c.ConfigObject.AdditionalItems["syntaxHighlight"] = new Dictionary<string, object>
              {
                  ["activated"] = false
              };
              c.SwaggerEndpoint("/swagger/v1/swagger.json", "Test.Core v1");
          });
      }
      app.UseHttpsRedirection();
      app.UseRouting();
      app.UseAuthorization();
      app.UseEndpoints(endpoints =>
      {
         endpoints.MapControllers();
      });
}
</code>
</pre>

**c) app.Map()**- These extensions are used as a convention for branching the pipeline. The map branches the request pipeline based on matches of the given request path. If the request path starts with the given path, the branch is executed.

<pre class="notranslate">
<code>
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)  
{  
    app.Map("/m1", HandleMapOne);  
    app.Map("/m2", appMap => {  
        appMap.Run(async context =>  
        {  
            await context.Response.WriteAsync("Hello from 2nd app.Map()");  
        });  
    });  
    app.Run(async (context) =>  
    {  
        await context.Response.WriteAsync("Hello from app.Run()");  
    });  
}  
private static void HandleMapOne(IApplicationBuilder app)  
{  
    app.Run(async context =>  
    {  
        await context.Response.WriteAsync("Hello from 1st app.Map()");  
    });   
}
</code>
</pre> 
